[ 4 4 3 2 8 1 7 3 ]
[ 4 4 3 2 8 1 7 3 1 2 3 4 ]
after remove-all(2):

[ 4 3 8 1 7 3 1 3 4 ]
list lenght? inside length functiong

print list2 now:	[ dd cc bb aa ]
print list2 reverse	[ aa bb cc dd ]
list  sorted?  0
list2 sorted?  0
list3 sorted?  1
fiveZ has this mandy 0s:	list2 has this many aa:	list3 has this many bb:	

TESTING equal_to
list vs list:inside length functiong
inside length functiong
YES SAME
list vs listB:inside length functiong
inside length functiong
not equal

popping back NODE: pop_back 
current list: [ 4 3 8 1 7 3 1 3 4 ]
removed back node
data stored: 4
list after popped value: 
[ 4 3 8 1 7 3 1 3 ]

Printing list in reverse RECURSIVLY!

PRINTING LIST original: 
[ 4 3 8 1 7 3 1 3 ]

PRINTING LIST AFTER reverse() FUNCT, reversing the list
[ 3 1 3 7 1 8 3 4 ]
TESTING fast_remove_all(1)
[ 3 1 3 7 1 8 3 4 ]
TESTING insert_sorted(sortedList)
original: [ 1 3 5 7 9 ]

adding 5: [ 1 3 5 6 7 9 ]
[ -22 1 3 5 6 7 9 ]
[ -22 1 3 5 6 7 9 66 ]

TESTING concat(list) 
list2: [ dd cc bb aa ]

list3: [ aa bb cc dd ]

list2.concat(list3): 
after concat list2 [ dd cc bb aa aa bb cc dd ]

after concat list3 [ ]
TESTING compare_with(list) 
other list is lexically before calling list
TESTING merge_with() function
list 8: [ 22 12 3 7 2 ]

list 9: [ 10 34 1 3 0 ]

AFTER MERGE: 
list 8: [ 22 12 3 7 2 10 34 1 3 0 ]

list 9: [ ]

[ 99 ]
TESTING clone() function 
List->print(): 	[ 3 1 3 7 1 8 3 4 ]
List clone: 	[ dd cc bb aa aa bb cc dd ]
TESTING prefix() module
original list: 	[ 3 1 3 7 1 8 3 4 ]
	*AFTER prefix*
original list: 	
[ dd cc bb aa aa bb cc dd ]
prefix list: 	
[ dd cc bb ]

TESTING prefix() module
original list: 	[ 5 1 1 7 8 1 3 5 ]
	*AFTER filter_leq is called with cutoff value 3*
original list: 	
[ 5 1 1 7 8 1 3 5 ]
original list after filter: 	
[ 7 8 ]
returned list: 	
[ 5 1 1 1 3 5 ]

TESTING suffix_maxes() module
listB: 	
[ 7 5 2 1 7 5 7 8 ]
listB after suffix_maxes: 	
[ 7 5 2 1 7 5 7 8 ]
new list: 	
[ 8 8 8 8 8 8 8 8 ]
